import json
import os
import sys
import re
from intelxapi import intelx
from leakcheck import LeakCheckAPI_Public


def get_intelx_api_token():
    config_file = os.path.join('config', 'api_tokens.json')
    if os.path.exists(config_file):
        with open(config_file, 'r', encoding='utf-8') as f:
            config = json.load(f)
            return config.get('intelx', '')
    return ''

def search_records(target):
    api_key = get_intelx_api_token()
    ix = intelx(api_key)
    # Use the free IntelX API endpoint
    ix.API_ROOT = "https://free.intelx.io"
    # Define the buckets to search in
    search_buckets = ["leaks.img.wikileaks", "leaks.img.general", "dumpster", "documents.img.scihub"]
    # Search for records with the target email (prefiing with "@") and limit to 10 results
    print("[*] Searching for leaked email addresses...")
    results = ix.search(f"@{target}", maxresults=10, buckets=search_buckets)

    output_dir = os.path.join("logs", target, "dns")
    os.makedirs(output_dir, exist_ok=True)
    output_file = os.path.join(output_dir, "records.json")

    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=4, ensure_ascii=False)

    print(f"[+] Records saved to {output_file}")

def search_emails(target):
    # Re-initialize the API with your API key
    api_key = get_intelx_api_token()
    ix = intelx(api_key)
    ix.API_ROOT = "https://free.intelx.io"

    # Load the records.json file generated by search_records
    records_file = os.path.join("logs", target, "dns", "records.json")
    if not os.path.exists(records_file):
        print("[-] records.json file not found.")
        return

    with open(records_file, 'r', encoding='utf-8') as f:
        data = json.load(f)

    records = data.get("records", [])
    found_emails = set()

    print("[+] Extracting email addresses from records...")

    for record in records:
        sid = record.get("storageid")
        bucket = record.get("bucket")
        ctype = record.get("type")
        mediatype = record.get("media", 24)

        if not sid or not bucket:
            continue

        try:
            # Retrieve file content using FILE_VIEW
            content = ix.FILE_VIEW(ctype=ctype, mediatype=mediatype, sid=sid, bucket=bucket)
            # Extract email addresses using a regular expression
            pattern = rf"[a-zA-Z0-9_.+-]+@{re.escape(target)}"
            emails = re.findall(pattern, content)
            for email in emails:
                found_emails.add(email)
        except Exception as e:
            print(f"[-] Error processing record {sid}: {e}")

    # Save the found email addresses to emails.txt
    output_file = os.path.join("logs", target, "dns", "emails.txt")
    with open(output_file, 'w', encoding='utf-8') as f:
        for email in found_emails:
            f.write(email + "\n")

    print(f"[+] Found {len(found_emails)} email addresses. Results saved to {output_file}")

def search_emails_leakcheck(target):
    public_api = LeakCheckAPI_Public()
    emails_file = os.path.join("logs", target, "dns", "emails.txt")
    if not os.path.exists(emails_file):
        print("[-] emails.txt file not found.")
        return
    with open(emails_file, 'r', encoding='utf-8') as f:
        emails = [line.strip() for line in f if line.strip()]
    pwned_results = {}
    for email in emails:
        try:
            result = public_api.lookup(query=email)
            pwned_results[email] = result
            print(f"[+] Result for {email}: {result}")
        except Exception as e:
            print(f"[-] Error for {email}: {e}")
    output_file = os.path.join("logs", target, "dns", "emails_pwned.json")
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(pwned_results, f, indent=4, ensure_ascii=False)

def generate_osint_mail_report(target):
    dns_dir = os.path.join("logs", target, "dns")
    report_dir = os.path.join("logs", target, "report")
    os.makedirs(report_dir, exist_ok=True)

    emails_file = os.path.join(dns_dir, "emails.txt")
    if os.path.exists(emails_file):
        with open(emails_file, "r", encoding="utf-8") as f:
            emails = [line.strip() for line in f if line.strip()]
    else:
        emails = []
    num_emails = len(emails)

    if num_emails == 0:
        return

    pwned_file = os.path.join(dns_dir, "emails_pwned.json")
    if os.path.exists(pwned_file):
        with open(pwned_file, "r", encoding="utf-8") as f:
            pwned_data = json.load(f)
    else:
        pwned_data = {}

    pwned_emails = []
    for email, details in pwned_data.items():
        if details.get("success") and details.get("found", 0) > 0:
            pwned_emails.append((email, details))
    num_pwned = len(pwned_emails)

    report_lines = []
    report_lines.append(f"A total of {num_emails} email addresses were found for the target '{target}':")
    report_lines.extend(emails)
    report_lines.append("")
    report_lines.append(f"Out of these, {num_pwned} have been pwned in various security breaches")
    report_lines.append("")
    for email, details in pwned_emails:
        found = details.get("found", 0)
        fields = details.get("fields", [])
        sources = details.get("sources", [])
        sources_str = []
        for src in sources:
            name = src.get("name", "Unknown")
            date = src.get("date", "")
            if date:
                sources_str.append(f"{name} ({date})")
            else:
                sources_str.append(name)
        report_lines.append(f"- {email} has been pwned in {found} breach(es).")
        report_lines.append(f"  Compromised fields: {', '.join(fields)}.")
        report_lines.append(f"  Breaches: {', '.join(sources_str) if sources_str else 'N/A'}.")
        report_lines.append("")

    report_text = "\n".join(report_lines)

    report_file = os.path.join(report_dir, "osint_mail.txt")
    with open(report_file, "w", encoding="utf-8") as f:
        f.write(report_text)

def run_osint_mail(target):
    print("[*] Running OSINT Mail module...")
    token = get_intelx_api_token()
    if not token:
        print("[-] IntelX API token not found, skipping functionality.")
        return
    search_records(target)
    search_emails(target)
    search_emails_leakcheck(target)
    generate_osint_mail_report(target)
    print("[+] OSINT Mail module completed.")


if __name__ == "__main__":
    target = sys.argv[1]
    run_osint_mail(target)
